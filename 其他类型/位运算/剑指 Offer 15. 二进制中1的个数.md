# 剑指Offer15. 二进制中1的个数:  
**题目地址：**[LeetCode](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)  
**题目描述：**  
请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。

**示例：**  
```
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

```

## 自解：
思路：将n与1按位与（&）得到最后一位是否为1，然后将n右移，在与1按位与，循环至n为0。
```cpp
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int count = 0;
        while(n!=0){
            if(n&1 == 1){
                count++;
            }
            n = n>>1;
        }
        return count;
    }
};
```

## 位运算优化：
观察这个运算：$n\&(n-1)$，其运算结果恰为把 n 的二进制位中的最低位的 1 变为 0 之后的结果。
如：$6\&(6-1)=4, 6=(110)_2,4=(100)_2$, 运算结果 4 即为把 6 的二进制位中的最低位的 1 变为 0 之后的结果。

这样我们可以利用这个位运算的性质加速我们的检查过程，在实际代码中，我们不断让当前的 $n$ 与 $n - 1$ 做与运算，直到 $n$ 变为 $0$ 即可。因为每次运算会使得 $n$ 的最低位的 $1$ 被翻转，因此运算次数就等于 $n$ 的二进制位中 $1$ 的个数。
```cpp
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int ret = 0;
        while (n) {
            n &= n - 1;
            ret++;
        }
        return ret;
    }
};
```