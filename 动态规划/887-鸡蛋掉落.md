### [887\. 鸡蛋掉落](https://leetcode-cn.com/problems/super-egg-drop/)

Difficulty: **困难**


给你 `k` 枚相同的鸡蛋，并可以使用一栋从第 `1` 层到第 `n` 层共有 `n` 层楼的建筑。

已知存在楼层 `f` ，满足 `0 <= f <= n` ，任何从 **高于** `f` 的楼层落下的鸡蛋都会碎，从 `f` 楼层或比它低的楼层落下的鸡蛋都不会破。

每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 `x` 扔下（满足 `1 <= x <= n`）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 **重复使用** 这枚鸡蛋。

请你计算并返回要确定 `f` **确切的值** 的 **最小操作次数** 是多少？

**示例 1：**

```
输入：k = 1, n = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。 
否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。 
如果它没碎，那么肯定能得出 f = 2 。 
因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 
```

**示例 2：**

```
输入：k = 2, n = 6
输出：3
```

**示例 3：**

```
输入：k = 3, n = 14
输出：4
```

**提示：**

*   `1 <= k <= 100`
*   `1 <= n <= 10<sup>4</sup>`


#### Solution

见注释

```cpp
​class Solution {
public:
    int superEggDrop(int k, int n) {
        //最多n次线性扫描
        vector<vector<int>> dp(k + 1, vector<int>(n + 1, 0)); // dp[k][m]表示有k个鸡蛋，最多试m次，可以确定出f时的最高楼层数
        int m = 0;
        // 1、无论你在哪层楼扔鸡蛋，鸡蛋只可能摔碎或者没摔碎，碎了的话就测楼下，没碎的话就测楼上。
        // 2、无论你上楼还是下楼，总的楼层数 = 楼上的楼层数 + 楼下的楼层数 + 1（当前这层楼）。
        while(dp[k][m]<n){
            m++;
            for(int k1=1; k1<=k; ++k1){
                dp[k1][m] = dp[k1-1][m-1] + dp[k1][m-1] + 1; // 往下走(碎了) + 往上走(没碎) + 本层
            }
        }
        return m;
    }
};
```